# Taken from auth0 package, but skips call to "userinfo" endpoint, which is unauthorized, and works better with mermaidr tokening system to recognize that the token is being called from Shiny and is therefore fresh and does not need to be refreshed in browser again

auth0_server_verify <- function(session, app, api, state) {
  u_search <- session[["clientData"]]$url_search
  params <- shiny::parseQueryString(u_search)

  if (auth0:::has_auth_code(params, state)) {
    cred <- httr::oauth2.0_access_token(api, app(redirect_uri), params$code)
    mermaidr_token <- mermaidr:::mermaid2.0_token(
      app = app(redirect_uri), endpoint = api, cache = FALSE, credentials = cred,
      user_params = list(grant_type = "authorization_code")
    )
    # Add $shiny = TRUE to the credentials
    mermaidr_token$credentials$shiny <- TRUE

    mermaidr_token <- httr::config(token = mermaidr_token)

    assign("auth0_credentials", mermaidr_token, envir = session$userData)
  }
}

auth0_server <- function(server, info) {
  disable <- getOption("auth0_disable")
  if (!is.null(disable) && disable) {
    server
  } else {
    if (missing(info)) info <- auth0::auth0_info()
    function(input, output, session) {
      shiny::isolate(auth0_server_verify(session, info$app, info$api, info$state))
      shiny::observeEvent(input[["._auth0logout_"]], logout())
      server(input, output, session)
    }
  }
}

#' The application server-side
#'
#' @param input,output,session Internal parameters for {shiny}.
#'     DO NOT REMOVE.
#' @noRd
app_server <- auth0_server(function(input, output, session) {
  authenticated <- shiny::reactiveVal(FALSE)

  # Set up reactive values ----
  r <- shiny::reactiveValues(
    is_project_admin = FALSE,
    auxiliary_columns_map = get_config("auxiliary_columns_map"),
    page_length = 10,
    ready_to_map_aux = FALSE,
    map_annotations_accordion_made = FALSE,
    aux_mapped = FALSE,
    preview_confirm_shown = 0,
    dev = FALSE,
    prod = FALSE,
    reset = NULL,
    # dev_scenario = "empties"
    # dev_scenario = "wrong_values"
    dev_scenario = "good_data",
    upload_contains_required_cols = FALSE,
    step_select_valid_project_done = FALSE,
    step_upload_valid_data_done = FALSE,
    step_map_auxiliary_fields_accordion_made_done = FALSE,
    step_map_auxiliary_fields_accordion_fully_done = FALSE,
    step_map_coralnet_labels_accordion_made_done = FALSE,
    step_map_coralnet_labels_done = FALSE,
    step_map_coralnet_labels_fully_done = FALSE,
    preview_confirm_shown = 0,
    reset_confirm_counter = 0
    # dev_scenario = "some_good_some_wrong"
    # dev_scenario = "transect_decimal"
  )

  # Get login info and hit initial endpoints ----
  shiny::observe(priority = 9999, {
    shinyjs::runjs("window.history.pushState({}, document.title, window.location.pathname);") # Remove code etc from URL so it can restart/refresh cleanly

    r$mermaidr_token <- session$userData$auth0_credentials

    shiny::req(r$mermaidr_token)

    # - User projects
    r$projects <- mermaidr::mermaid_get_my_projects(token = r$mermaidr_token) %>%
      dplyr::arrange(name)

    # - "me" endpoint
    r$me <- mermaidr::mermaid_get_me(token = r$mermaidr_token)

    # - benthic attributes
    r$benthic_attributes <- mermaidr::mermaid_get_reference("benthicattributes") %>%
      dplyr::filter(status == "Open") %>%
      dplyr::pull(name)

    # - growth forms
    growth_forms <- mermaidr::mermaid_get_endpoint("choices") %>%
      dplyr::filter(name == "growthforms") %>%
      dplyr::pull(data)

    r$growth_forms <- growth_forms[[1]][["name"]] %>%
      sort()

    waiter::waiter_hide()
  })

  # Upload instructions ----
  mod_upload_instructions_server("instructions")

  # Reset ----
  mod_reset_server("reset", r)

  # Get projects ----
  # This will also get the project template/options, and flag if they are not an admin of the selected project
  mod_select_project_server("select_project", r)

  # Upload CoralNet annotations ----
  # (only once confirmed that they are a project admin)
  mod_upload_data_server("upload_data", r)

  # Parse annotations -----
  # Map and check auxiliary fields
  # Map CoralNet labels to MERMAID attributes
  mod_map_auxiliary_fields_server("map_auxliary_fields", r)

  # Reshape annotations for ingestion ----
  mod_reshape_annotations_server("reshape_annotations", r)

  # Preview/confirm ingestion ----
  mod_ingestion_preview_and_confirm_server("preview_and_confirm", r)

  # Do ingestion ----
  mod_ingestion_do_server("ingest", r)

  # Ingestion results -----

  # Insert and open accordions / close them when that step is done, since they go into global ns ----

  ##  Map auxiliary fields ----
  shiny::observe({
    shiny::req(r$step_map_auxiliary_fields_accordion_made_done)

    # Insert panel
    bslib::accordion_panel_insert("accordion", r$accordion_map_annotation_fields)

    # Open panel
    bslib::accordion_panel_open("accordion", "map-auxiliary-fields")
  }) %>%
    shiny::bindEvent(r$step_map_auxiliary_fields_accordion_made_done)

  ### Close panel if all annotations are good ----
  shiny::observe({
    shiny::req(r$step_map_auxiliary_fields_valid_done)
    bslib::accordion_panel_close("accordion", "map-auxiliary-fields")

    r$step_map_auxiliary_fields_accordion_fully_done <- TRUE
  }) %>%
    shiny::bindEvent(r$step_map_auxiliary_fields_valid_done)

  ## Map labels ----

  shiny::observe({
    shiny::req(r$accordion_map_coralnet_labels)
    # Insert panel
    bslib::accordion_panel_insert("accordion", r$accordion_map_coralnet_labels)

    # Open panel
    bslib::accordion_panel_open("accordion", "map-coralnet-labels")
  })

  ### Close panel if all labels are good ----
  shiny::observe({
    shiny::req(r$step_map_coralnet_labels_done)
    bslib::accordion_panel_close("accordion", "map-coralnet-labels")

    r$step_map_coralnet_labels_fully_done <- TRUE
  }) %>%
    shiny::bindEvent(r$step_map_coralnet_labels_done)

  ## Preview/download/confirm ---

  shiny::observe({
    # Insert panel
    bslib::accordion_panel_insert("accordion", r$accordion_preview_download_confirm)

    # Open panel
    bslib::accordion_panel_open("accordion", "preview-download-confirm")
  })

  ## Remove panels on reset ----

  shiny::observe({
    shiny::req(r$reset > 0)

    # Works even if the panels have not been created/added <3
    bslib::accordion_panel_remove("accordion", "map-auxiliary-fields")
    bslib::accordion_panel_remove("accordion", "map-coralnet-labels")
    bslib::accordion_panel_remove("accordion", "preview-download-confirm")
  }) %>%
    shiny::bindEvent(r$reset)
})
